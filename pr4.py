#!/usr/bin/env python
"""
algorithmic thinking, project 4
"""
import math
import random
import pdb

def build_scoring_matrix(alphabet='AGCT',diag_score=10,off_diag_score=4,dash_score=-6):
    """scoring matrix
    alphabet is strign, list or tuple of valid characters
    diag_score is score of matches
    off_diag_score is score of all mismatches
    dash_score is score of gaps
    
    returns scoring matrix as dict of dicts 
    """
    alpha=['-']+list(alphabet)
    out={itm:{inneritm:off_diag_score for inneritm in alpha} for itm in alpha}  #initialize to most common value
    for itm in alpha:
        out[itm][itm]=diag_score
        out['-'][itm]=dash_score
        out[itm]['-']=dash_score
    return out
    
def compute_alignment_matrix(seq_x='AA',seq_y='TAAT',scoring_matrix=build_scoring_matrix(),global_flag=True):
    """
    seq_x and seq_y are sequences
    scoring_matrix is generated by build_socring_matrix
    global_flag flag indicates whether to perform global or local alignment
    
    returns alignment matrix as list of lists
    """
    numx=len(seq_x)+1
    numy=len(seq_y)+1
    mat=[ [0 for idx1 in range(numy)] for idx2 in range(numx)]
    for idx in range(1,numx):
        mat[idx][0]=mat[idx-1][0]+scoring_matrix[ seq_x[idx-1] ]['-']
        if not global_flag:
            mat[idx][0]=max(mat[idx][0],0)
    for idy in range(1,numy):
        mat[0][idy]=mat[0][idy-1]+scoring_matrix['-'][ seq_y[idy-1] ]
        if not global_flag:
            mat[0][idy]=max(mat[0][idy],0)
    for idx in range(1,numx):
        for idy in range(1,numy):
            vert=mat[idx-1][idy]+scoring_matrix[ seq_x[idx-1] ]['-']
            horiz=mat[idx][idy-1]+scoring_matrix['-'][ seq_y[idy-1] ]
            diag=mat[idx-1][idy-1]+scoring_matrix[ seq_x[idx-1] ][ seq_y[idy-1] ]
            mat[idx][idy]=max(vert,horiz,diag)
            if not global_flag:
                mat[idx][idy]=max(mat[idx][idy],0)
    return mat
    
def compute_global_alignment(seq_x='AA',seq_y='TAAT',scoring_matrix=build_scoring_matrix(), alignment_matrix=compute_alignment_matrix()):
    """
    seq_x and seq_y are sequences
    scoring_matrix is generated by build_socring_matrix
    alignment_matrix is generated by compute_alignment_matrix
    
    returns alignment of seq_x & seq_y
    """
    numx=len(seq_x)
    numy=len(seq_y)
    idx,idy=numx,numy
    #pdb.set_trace()
    score=alignment_matrix[idx][idy]  #for global alignment score is s[|x|,|y|]
    outx=''
    outy=''
    while idx>0 and idy>0:
        curscore=alignment_matrix[idx][idy]
        if curscore==alignment_matrix[idx-1][idy-1]+scoring_matrix[seq_x[idx-1]][seq_y[idy-1]]:
            outx=seq_x[idx-1]+outx
            outy=seq_y[idy-1]+outy
            idx-=1
            idy-=1
        elif curscore==alignment_matrix[idx-1][idy]+scoring_matrix[seq_x[idx-1]]['-']:
            outx=seq_x[idx-1]+outx
            outy='-'+outy
            idx-=1
        else:
            outx='-'+outx
            outy=seq_y[idy-1]+outy
            idy-=1
    while idx>0:
        outx=seq_x[idx-1]+outx
        outy='-'+outy
        idx-=1
    while idy>0:
        outx='-'+outx
        outy=seq_y[idy-1]+outy
        idy-=1
    return (score,outx,outy)
    
def compute_local_alignment(seq_x='AA',seq_y='TAAT',scoring_matrix=build_scoring_matrix(), alignment_matrix=compute_alignment_matrix(global_flag=False)):
    """
    seq_x and seq_y are sequences
    scoring_matrix is generated by build_socring_matrix
    alignment_matrix is generated by compute_alignment_matrix with global_flag=False
    
    returns alignment of seq_x & seq_y
    """
    numx=len(seq_x)
    numy=len(seq_y)
    #pdb.set_trace()
    #####find max score in alignment_matrix
    maxscore=[-float('Inf'),0,0]  #traverse alignment matrixand identify maxium score(s)
    for idx in range(len(alignment_matrix)):
        for idy in range(len(alignment_matrix[0])):
            if alignment_matrix[idx][idy]>maxscore[0]:
                maxscore=[alignment_matrix[idx][idy],idx,idy]
    
    score,idx,idy=maxscore
    outx=''
    outy=''
    while idx>0 and idy>0:
        curscore=alignment_matrix[idx][idy]
        if curscore<=0:
            break
        if curscore==alignment_matrix[idx-1][idy-1]+scoring_matrix[seq_x[idx-1]][seq_y[idy-1]]:
            outx=seq_x[idx-1]+outx
            outy=seq_y[idy-1]+outy
            idx-=1
            idy-=1
        elif curscore==alignment_matrix[idx-1][idy]+scoring_matrix[seq_x[idx-1]]['-']:
            outx=seq_x[idx-1]+outx
            outy='-'+outy
            idx-=1
        else:
            outx='-'+outx
            outy=seq_y[idy-1]+outy
            idy-=1
    #while idx>0:
    #    outx=seq_x[idx-1]+outx
    #    outy='-'+outy
    #    idx-=1
    #while idy>0:
    #    outx='-'+outx
    #    outy=seq_y[idy-1]+outy
    #    idy-=1
    return (score,outx,outy)
    