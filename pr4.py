#!/usr/bin/env python
"""
algorithmic thinking, project 4
"""
import math
import random
import pdb

def build_scoring_matrix(alphabet='AGCT',diag_score=10,off_diag_score=4,dash_score=-6):
    """scoring matrix
    alphabet is strign, list or tuple of valid characters
    diag_score is score of matches
    off_diag_score is score of all mismatches
    dash_score is score of gaps
    
    returns scoring matrix as dict of dicts 
    """
    alpha=['-']+list(alphabet)
    out={itm:{inneritm:off_diag_score for inneritm in alpha} for itm in alpha}  #initialize to most common value
    for itm in alpha:
        out[itm][itm]=diag_score
        out['-'][itm]=dash_score
        out[itm]['-']=dash_score
    return out
    
def compute_aligment_matrix(seq_x='AA',seq_y='TAAT',scoring_matrix=build_scoring_matrix(),global_flag=True):
    """
    seq_x and seq_y are sequences
    scoring_matrix is generated by build_socring_matrix
    global_flag flag indicates whether to perform global or local alignment
    
    returns alignment matrix as list of lists
    """
    numx=len(seq_x)+1
    numy=len(seq_y)+1
    mat=[ [0 for idx1 in range(numy)] for idx2 in range(numx)]
    for idx in range(1,numx):
        mat[idx][0]=mat[idx-1][0]+scoring_matrix[ seq_x[idx-1] ]['-']
        if not global_flag:
            mat[idx][0]=max(mat[idx][0],0)
    for idy in range(1,numy):
        mat[0][idy]=mat[0][idy-1]+scoring_matrix['-'][ seq_y[idy-1] ]
        if not global_flag:
            mat[0][idy]=max(mat[0][idy],0)
    for idx in range(1,numx):
        for idy in range(1,numy):
            vert=mat[idx-1][idy]+scoring_matrix[ seq_x[idx-1] ]['-']
            horiz=mat[idx][idy-1]+scoring_matrix['-'][ seq_y[idy-1] ]
            diag=mat[idx-1][idy-1]+scoring_matrix[ seq_x[idx-1] ][ seq_y[idy-1] ]
            mat[idx][idy]=max(vert,horiz,diag)
            if not global_flag:
                mat[idx][idy]=max(mat[idx][idy],0)
    return mat
    
def compute_global_alignment(seq_x='AA',seq_y='TAAT',scoring_matrix=build_scoring_matrix(),alignment_matrix=compute_alignment_matrix()):
    """
    seq_x and seq_y are sequences
    scoring_matrix is generated by build_socring_matrix
    
    returns alignment of seq_x & seq_y
    """
    numx=len(seq_x)+1
    numy=len(seq_y)+1
    idx,idy=numx,numy
    score=alignment_matrix[numx][numy]  #for global alignment score is s[|x|,|y|]
    outx=''
    outy=''
    while idx>0 and idy>0:
        pass
    